<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.16"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ColorShapeLinks AI: Thinker implementation guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ColorShapeLinks AI
   &#160;<span id="projectnumber">v1.0.0-beta</span>
   </div>
   <div id="projectbrief">An AI competition for the IEEE Conference on Games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('thinker-implementation-guide.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Thinker implementation guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md2">Introduction</a></li>
<li class="level1"><a href="#rules">Rules and restrictions for the AI source code</a></li>
<li class="level1"><a href="#abstractthinker">The AbstractThinker base class</a><ul><li class="level2"><a href="#autotoc_md3">Overriding the Setup() method</a></li>
<li class="level2"><a href="#autotoc_md4">Overriding the Think() method</a></li>
<li class="level2"><a href="#autotoc_md5">Overriding the ToString() method</a></li>
</ul>
</li>
<li class="level1"><a href="#devenv">Setting up the development environment</a></li>
<li class="level1"><a href="#testing">Testing an AI thinker in isolation</a></li>
<li class="level1"><a href="#minimax">Implementing a simple Minimax player</a></li>
</ul>
</div>
<div class="textblock"><p>A guide on how to implement an AI thinker</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Introduction</h1>
<p>This guide describes how to implement an AI thinker for the <a class="el" href="namespace_color_shape_links.html" title="The ColorShapeLinks game, an unbounded version of the Simplexity board game.">ColorShapeLinks</a> competition. This is a simple process, requiring at the bare minimum the creation of a class which extends <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html">another class</a> and overrides <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">one of its methods</a>. The <a class="el" href="quick-start.html">Quick start</a> guide shows how to get started quickly by simply dropping the new AI class in the <a href="https://github.com/VideojogosLusofona/color-shape-links-ai-competition/tree/master/ConsoleApp/ColorShapeLinks/TextBased">console app</a> or <a href="https://github.com/VideojogosLusofona/color-shape-links-ai-competition/tree/master/UnityApp/Assets/Scripts">Unity app</a> folders. However, implementing a competitive AI thinker will most likely require to know a bit more about the <a class="el" href="thinker-implementation-guide.html#rules">source code rules and restriction</a> and about the <a class="el" href="thinker-implementation-guide.html#abstractthinker">AbstractThinker base class</a>. Setting up a proper <a class="el" href="thinker-implementation-guide.html#devenv">development environment</a> and being able to adequately <a class="el" href="thinker-implementation-guide.html#testing">test</a> the developed code is also essential. This guide closes with a tutorial on how to implement a <a class="el" href="thinker-implementation-guide.html#minimax">basic Minimax AI</a> with a very simple heuristic.</p>
<h1><a class="anchor" id="rules"></a>
Rules and restrictions for the AI source code</h1>
<p>The source code of AI thinkers must follow these rules and restrictions:</p>
<ul>
<li>Can only use cross-platform <a href="https://docs.microsoft.com/dotnet/standard/net-standard">.NET Standard 2.0</a> API calls in C#.</li>
<li>Can use additional libraries which abide by these same rules.</li>
<li>Both the AI code and libraries must be made available under a <a href="https://opensource.org/licenses">valid open source license</a>, although AI codes can be open-sourced only after the competition deadline.</li>
<li>Must run in the same process that invokes it.</li>
<li>Can be multithreaded and use <a href="https://docs.microsoft.com/dotnet/csharp/programming-guide/unsafe-code-pointers/"><code>unsafe</code></a> contexts.</li>
<li>Cannot <em>think</em> in its opponent time (e.g., by using a background thread).</li>
<li>Must acknowledge <a href="https://docs.microsoft.com/dotnet/api/system.threading.cancellationtoken">cancellation requests</a>, in which case it should terminate quickly and in an orderly fashion.</li>
<li>Can only probe the environment for the number of processor cores. It cannot search or use any other information, besides what is already available in the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html">AbstractThinker</a> class or passed to the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">Think()</a> method, e.g., such as using reflection to probe the capabilities of its opponents.</li>
<li>Cannot use more than 2GB of memory during the course of a match.</li>
<li>Cannot be more than 250kb in size (including libraries, excluding comments).</li>
<li>Cannot save or load data from disk.</li>
</ul>
<h1><a class="anchor" id="abstractthinker"></a>
The AbstractThinker base class</h1>
<p>The first step to implement an AI thinker is to extend the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html">AbstractThinker</a> base class. This class has three overridable methods, but it's only mandatory to override one of them, as shown in the following table:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Method  </th><th class="markdownTableHeadNone">Mandatory override?  </th><th class="markdownTableHeadNone">Purpose   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa0f63b1df3274e6ef69f4a060869d7c0">Setup()</a>  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">Setup the AI thinker.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">Think()</a>  </td><td class="markdownTableBodyNone">Yes  </td><td class="markdownTableBodyNone">Select the next move to perform.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa73e7c4dd1df5fd5fbf81c7764ee1533">ToString()</a>  </td><td class="markdownTableBodyNone">No  </td><td class="markdownTableBodyNone">Return the AI thinker's name.   </td></tr>
</table>
<p>There's also the non-overridable <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#a3610cd145e44a055a68076043d7b6cdc">OnThinkingInfo()</a> method, which can be invoked for producing thinking information, mainly for debugging purposes. In the <a class="el" href="unity-guide.html">Unity</a> frontend this information is printed on Unity's console, while in the <a class="el" href="console-guide.html">console</a> frontend the information is forwarded to the registered <a class="el" href="interface_color_shape_links_1_1_text_based_1_1_lib_1_1_i_thinker_listener.html">thinker listeners</a>.</p>
<p>Classes extending <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html">AbstractThinker</a> also inherit a number of useful read-only properties, namely board/match configuration properties (<a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aacd84fe3991a31360df9315e81a5759a">No. of rows</a>, <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ab52455671cd68f3d2d744fb7df40b5fb">No. of columns</a>, <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#affb43992a9e0eea81dfae30ec703fefc">No. of pieces in sequence to win a game</a>, <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#a4e93097d0d2a22894ffd3e0afbaf679d">No. of initial round pieces per player</a> and <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#a84fc3b394aa124400d20a9b85b47e365">No. of initial square pieces per player</a>) and the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#a674bbef040e3de89fabd008aec84935a">time limit for the AI to play</a>. Concerning the board/match configuration properties, these are also available in the <a class="el" href="class_color_shape_links_1_1_common_1_1_board.html">board</a> object given as a parameter to the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">Think()</a> method. However, the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa0f63b1df3274e6ef69f4a060869d7c0">Setup()</a> method can only access them via the inherited properties.</p>
<p>The following subsections address the overriding of each of these three methods.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
Overriding the Setup() method</h2>
<p>If an AI thinker needs to be configured before starting to play, the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa0f63b1df3274e6ef69f4a060869d7c0">Setup()</a> method is the place to do it. This method receives a single argument, a <code>string</code>, which can contain thinker-specific parameters, such as maximum search depth, heuristic to use, and so on. It is the thinker's responsibility to parse this string. In the <a class="el" href="unity-guide.html">Unity</a> frontend, the string is specified in the "Thinker params" field of the <a class="el" href="class_color_shape_links_1_1_unity_app_1_1_a_i_player.html">AIPlayer</a> component. When using the <a class="el" href="console-guide.html">console</a> frontend, the string is passed via the <code>--white/red-params</code> option for simple matches, or after the thinker's fully qualified name in the configuration file of a complete session. Besides the parameters string, the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa0f63b1df3274e6ef69f4a060869d7c0">Setup()</a> method also has access to board/match properties inherited from the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html">base class</a>.</p>
<p>The same AI thinker can represent both players in matches, as well as more than one player in sessions/tournaments. Additionally, separate instances of the same AI thinker can be configured with different parameters. In such a case it might be useful to also override the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa73e7c4dd1df5fd5fbf81c7764ee1533">ToString()</a> method for discriminating between the instances configured differently.</p>
<p>Note that concrete AI thinkers require a parameterless constructor in order to be found by the various frontends. Such constructor <a href="https://docs.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/constructors#parameterless-constructors">exists by default in C# classes if no other constructors are defined</a>. However, it is not advisable to use a parameterless constructor to setup an AI thinker, since the various board/match properties will not be initialized at that time. This is yet another good reason to perform all thinker configuration tasks in the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa0f63b1df3274e6ef69f4a060869d7c0">Setup()</a> method. In any case, concrete AI thinkers don't need to provide an implementation of this method if they are not parameterizable.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Overriding the Think() method</h2>
<p>The <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">Think()</a> method is where the AI actually does its job and is the only mandatory override when extending the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html">AbstractThinker</a> class. This method accepts the <a class="el" href="class_color_shape_links_1_1_common_1_1_board.html">game board</a> and a <a href="https://docs.microsoft.com/dotnet/api/system.threading.cancellationtoken">cancellation token</a>, returning a <a class="el" href="struct_color_shape_links_1_1_common_1_1_a_i_1_1_future_move.html">FutureMove</a>. In other words, the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">Think()</a> method accepts the game board, the AI decides the best move to perform, returning it. The selected move will eventually be executed by the match engine.</p>
<p>The <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">Think()</a> method is called in a separate thread. As such, it should only access local instance data. The main thread may ask the AI to stop <em>thinking</em>, for example if the thinking time limit has expired. Thus, while <em>thinking</em>, the AI should frequently test if a cancellation request was made to the <a href="https://docs.microsoft.com/dotnet/api/system.threading.cancellationtoken">cancellation token</a>. If so, it should return immediately with no move performed, as exemplified in the following code:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (ct.IsCancellationRequested) <span class="keywordflow">return</span> FutureMove.NoMove;</div>
</div><!-- fragment --><p>The <a class="el" href="class_color_shape_links_1_1_common_1_1_board.html">game board</a> can be freely modified within the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">Think()</a> method, since this is a copy and not the original game board being used in the main thread. More specifically, the thinker can try moves with the <a class="el" href="class_color_shape_links_1_1_common_1_1_board.html#af97ec0281f2420e4594b1000b609ab73">DoMove()</a> method, and cancel them with the <a class="el" href="class_color_shape_links_1_1_common_1_1_board.html#a4f5022f3b6c72a4bba9fad39f631beee">UndoMove()</a> method. The board keeps track of the move history, so the thinker can perform any sequence of moves, and roll them back afterwards.</p>
<p>The <a class="el" href="class_color_shape_links_1_1_common_1_1_board.html#a7088451ab7b87b7cac15be65ea521306">CheckWinner()</a> method is useful to determine if there's a winner. If there is one, the solution is placed in the method's optional parameter.</p>
<p>For building heuristics, the public read-only variable <a class="el" href="class_color_shape_links_1_1_common_1_1_board.html#a518b85b41ceb010c4f7104395977ff85">winCorridors</a> will probably be useful. This variable is a collection containing all corridors (sequences of positions) where promising or winning piece sequences may exist.</p>
<p>The AI thinker will lose the match in the following situations:</p>
<ul>
<li>Causes or throws an exception.</li>
<li>Takes too long to play.</li>
<li>Returns an invalid move, such as:<ul>
<li>Column out of bounds (&lt;0 or &gt;=<a class="el" href="class_color_shape_links_1_1_common_1_1_board.html#a09a399bb7ae73ceaa1ece104186fc2bb">cols</a>).</li>
<li>Column is already full.</li>
<li>No more pieces with the specified shape are available.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md5"></a>
Overriding the ToString() method</h2>
<p>By default, the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa73e7c4dd1df5fd5fbf81c7764ee1533">ToString()</a> method removes the namespace from the thinkers' fully qualified name, as well as the "thinker", "aithinker" or "thinkerai" suffixes. However, this method can be overriden in order to behave differently. One such case is when thinkers are parameterizable, and differentiating between specific parametrizations during matches and sessions becomes important. For example, if an AI thinker is configurable with a <code>maxDepth</code> parameter, the following would keep the base method behavior, while adding the value of the maximum depth to the thinkers' name:</p>
<div class="fragment"><div class="line"><span class="comment">// If the FQN of this class is My.SuperAIThinker and maxDepth is 6, this</span></div>
<div class="line"><span class="comment">// method will return &quot;SuperD6&quot;.</span></div>
<div class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">string</span> ToString()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> base.ToString() + <span class="stringliteral">&quot;D&quot;</span> + maxDepth;</div>
<div class="line">}</div>
</div><!-- fragment --><p>In any case, concrete AI thinkers are not required to override this method.</p>
<h1><a class="anchor" id="devenv"></a>
Setting up the development environment</h1>
<p>The most basic development environment for a <a class="el" href="namespace_color_shape_links.html" title="The ColorShapeLinks game, an unbounded version of the Simplexity board game.">ColorShapeLinks</a> AI thinker consists of cloning the repository and just place a new class directly in the <a href="https://github.com/VideojogosLusofona/color-shape-links-ai-competition/tree/master/ConsoleApp/ColorShapeLinks/TextBased">console app</a> or <a href="https://github.com/VideojogosLusofona/color-shape-links-ai-competition/tree/master/UnityApp/Assets/Scripts">Unity app</a> project folders. This is not practical, however, especially when using a version control system. Furthermore, although AI thinkers can be tested in <a class="el" href="unity-guide.html">Unity</a>, serious development is much simpler within the context of the <a class="el" href="console-guide.html">console</a> frontend. As such, this section focuses on setting up a development environment within that context. Nonetheless, testing in <a class="el" href="unity-guide.html">Unity</a> can still be done by copying the project folder to the <a href="https://github.com/VideojogosLusofona/color-shape-links-ai-competition/tree/master/UnityApp/Assets/Scripts">Unity app scripts folder</a>.</p>
<p>The following commands are cross-platform and work in Linux, Windows (PowerShell), and macOS, requiring only <a href="https://dotnet.microsoft.com/download">.NET Core</a> ≥ 3.1 to be installed. On Windows, replace slashes <code>/</code> with backslashes <code>\</code> when referencing local paths. The steps for setting up a development environment are as follows:</p>
<ol type="1">
<li>Create a development folder and <code>cd</code> into it: <div class="fragment"><div class="line">$ mkdir color-shape-links-ai-dev</div>
<div class="line">$ cd color-shape-links-ai-dev</div>
</div><!-- fragment --></li>
<li>Clone the <a class="el" href="namespace_color_shape_links.html" title="The ColorShapeLinks game, an unbounded version of the Simplexity board game.">ColorShapeLinks</a> repository (requires <a href="https://git-scm.com/downloads">Git</a> and <a href="https://git-lfs.github.com/">Git LFS</a>): <div class="fragment"><div class="line">$ git clone --recurse-submodules https://github.com/VideojogosLusofona/color-shape-links-ai-competition.git</div>
</div><!-- fragment --></li>
<li>Create a new .NET Standard class library, <code>cd</code> into the project's folder and remove the default class: <div class="fragment"><div class="line">$ dotnet new classlib -n MyAIThinkerProjectName</div>
<div class="line">$ cd MyAIThinkerProjectName</div>
<div class="line">$ rm Class1.cs</div>
</div><!-- fragment --></li>
<li>Add the <a class="el" href="namespace_color_shape_links_1_1_common.html" title="The common code between all ColorShapeLinks implementations.">ColorShapeLinks.Common</a> project as a dependency: <div class="fragment"><div class="line">$ dotnet add reference ../color-shape-links-ai-competition/ConsoleApp/ColorShapeLinks/Common</div>
</div><!-- fragment --></li>
<li><em>Optional:</em> Initialize a Git repository, add a <code>.gitignore</code> file and make the first commit: <div class="fragment"><div class="line">$ git init</div>
<div class="line">$ dotnet new gitignore</div>
<div class="line">$ git add .</div>
<div class="line">$ git commit -m &quot;First commit&quot;</div>
</div><!-- fragment --></li>
<li>Using a code editor or IDE (e.g. <a href="https://code.visualstudio.com/">VS Code</a>), create a new class which extends <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html">AbstractThinker</a> and implements the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#ac8039cba1e4ececb04322fb8e7610f0e">Think()</a> method: <div class="fragment"><div class="line"><span class="keyword">using</span> System.Threading;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespace_color_shape_links.html">ColorShapeLinks</a>.<a class="code" href="namespace_color_shape_links_1_1_common.html">Common</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespace_color_shape_links.html">ColorShapeLinks</a>.<a class="code" href="namespace_color_shape_links_1_1_common.html">Common</a>.<a class="code" href="namespace_color_shape_links_1_1_common_1_1_a_i.html">AI</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyAIThinker : AbstractThinker</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> FutureMove Think(Board board, CancellationToken ct)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Will always lose by making a &quot;No move&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> FutureMove.NoMove;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Build the code: <div class="fragment"><div class="line">$ dotnet build</div>
</div><!-- fragment --></li>
<li>Using the <a class="el" href="console-guide.html">console</a> app, check if the <code>MyAIThinker</code> class appears in the "Known thinkers:" section (on Windows replace <code>$</code><code>(pwd)</code> with the full path to the current folder): <div class="fragment"><div class="line">$ dotnet run -p ../color-shape-links-ai-competition/ConsoleApp/ColorShapeLinks/TextBased/App -- info -a $(pwd)/bin/Debug/netstandard2.0/MyAIThinkerProjectName.dll</div>
</div><!-- fragment --></li>
<li>Using the <a class="el" href="console-guide.html">console</a> app, run a match between <code>MyAIThinker</code> and the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_examples_1_1_random_a_i_thinker.html">random AI</a> provided with the development framework (on Windows replace <code>$</code><code>(pwd)</code> with the full path to the current folder): <div class="fragment"><div class="line">$ dotnet run -p ../color-shape-links-ai-competition/ConsoleApp/ColorShapeLinks/TextBased/App -- match -a $(pwd)/bin/Debug/netstandard2.0/MyAIThinkerProjectName.dll -W ColorShapeLinks.Common.AI.Examples.RandomAIThinker -R MyAIThinker</div>
</div><!-- fragment --> The <code>MyAIThinker</code> will lose, since it doesn't make a valid move. The <a class="el" href="thinker-implementation-guide.html#minimax">Implementing a simple Minimax player</a> section describes the implementation of a basic AI which can beat the random player (most of the time).</li>
</ol>
<p>The <a class="el" href="console-guide.html">console guide</a> describes all the available options for the console app, in particular the ones used in the above steps.</p>
<h1><a class="anchor" id="testing"></a>
Testing an AI thinker in isolation</h1>
<p>During development, it is crucial to be able to test the AI thinker in isolation, i.e., outside of running matches and sessions. This is easy to accomplish, requiring the creation of a test project which references the <a class="el" href="namespace_color_shape_links_1_1_common.html">Common</a> project, as well as the AI thinker-specific project (which we called <code>MyAIThinkerProjectName</code> in the previous section). However, there is an important caveat to be aware of:</p>
<dl class="section attention"><dt>Attention</dt><dd>Properties inherited from <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html">AbstractThinker</a> will not be automatically initialized if the concrete thinker is instantiated directly.</dd></dl>
<p>There are two ways to solve this problem:</p>
<ol type="1">
<li>Use reflection to initialize the private instance variables in the base class which provide the property values.</li>
<li>Use a <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_thinker_prototype.html">ThinkerPrototype</a> to <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_thinker_prototype.html#ae87c188c0557a53fdc85b64e6a3cd34d">create</a> an instance of the concrete AI thinker.</li>
</ol>
<p>The second option is preferred, since it not only initializes the base class properties, as it also invokes the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_abstract_thinker.html#aa0f63b1df3274e6ef69f4a060869d7c0">Setup()</a> method. The <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_thinker_prototype.html#ae99e021fdbae1eb979983aa40d764886">ThinkerPrototype constructor</a> requires three parameters:</p>
<ol type="1">
<li>A string containing the thinker's fully qualified name.</li>
<li>A string containing the thinker's configuration parameters.</li>
<li>An object which implements the <a class="el" href="interface_color_shape_links_1_1_common_1_1_session_1_1_i_match_config.html">IMatchConfig</a> interface.</li>
</ol>
<p>The last parameter is generally a frontend-dependent type. However, the <a class="el" href="namespace_color_shape_links_1_1_common.html">Common</a> assembly contains the <a class="el" href="class_color_shape_links_1_1_common_1_1_session_1_1_match_config.html">MatchConfig</a> helper class, a simple container of match properties which can be used for this purpose. As such, instatiating an AI thinker in isolation can be done as follows:</p>
<div class="fragment"><div class="line">MatchConfig mc = <span class="keyword">new</span> MatchConfig(); <span class="comment">// Use default values</span></div>
<div class="line">ThinkerPrototype tp = <span class="keyword">new</span> ThinkerPrototype(<span class="stringliteral">&quot;MyAIThinker&quot;</span>, <span class="stringliteral">&quot;&quot;</span>, mc);</div>
<div class="line">IThinker thinker = tp.Create();</div>
</div><!-- fragment --><h1><a class="anchor" id="minimax"></a>
Implementing a simple Minimax player</h1>
<p>In this section we discuss the implementation of a basic <a href="https://en.wikipedia.org/wiki/Minimax">Minimax</a> AI thinker with a very simple heuristic. A minimax algorithm is a <a href="https://en.wikipedia.org/wiki/Minimax">"recursive algorithm for choosing the next move in (...) a two-player game"</a>. The most basic version of this algorithm tries out all possible moves, branching out the game tree down to a maximum depth, since the search space would otherwise be too large. Most board states searched by the algorithm, even when it reaches maximum depth, will not be final boards. As such, we'll need an <a href="https://en.wikipedia.org/wiki/Heuristic">heuristic</a> function to evaluate these non-final boards. An heuristic is <a href="https://en.wikipedia.org/wiki/Heuristic">"an educated guess, an intuitive judgment"</a> which helps us evaluate the "goodness" of a board state. The better the heuristic, the better the AI will be able to evaluate intermediate boards, and the better it'll play.</p>
<p>Let's start with the template presented in the previous section:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> System.Threading;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespace_color_shape_links.html">ColorShapeLinks</a>.<a class="code" href="namespace_color_shape_links_1_1_common.html">Common</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespace_color_shape_links.html">ColorShapeLinks</a>.<a class="code" href="namespace_color_shape_links_1_1_common.html">Common</a>.<a class="code" href="namespace_color_shape_links_1_1_common_1_1_a_i.html">AI</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyAIThinker : AbstractThinker</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> FutureMove Think(Board board, CancellationToken ct)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Will always lose by making a &quot;No move&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> FutureMove.NoMove;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>A minimax algorithm works by maximizing the heuristic score of all possible moves when it's the AI's turn to play, and minimizing it when it's the opponent's turn. As such, a <code>Minimax()</code> function requires:</p>
<ul>
<li>The current board state.</li>
<li>The color of the AI player.</li>
<li>The color of who's playing in the current turn.</li>
<li>The current depth.</li>
<li>The maximum depth.</li>
</ul>
<p>It will also need the <a href="https://docs.microsoft.com/dotnet/api/system.threading.cancellationtoken"><code>CancellationToken</code></a>, so it can check for cancellation requests from the main thread. As such, the code will look something like:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> System.Threading;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespace_color_shape_links.html">ColorShapeLinks</a>.<a class="code" href="namespace_color_shape_links_1_1_common.html">Common</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespace_color_shape_links.html">ColorShapeLinks</a>.<a class="code" href="namespace_color_shape_links_1_1_common.html">Common</a>.<a class="code" href="namespace_color_shape_links_1_1_common_1_1_a_i.html">AI</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyAIThinker : AbstractThinker</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Maximum depth, set it at 3 for now</span></div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">int</span> maxDepth = 3;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The Think() method (mandatory override) is invoked by the game engine</span></div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> FutureMove Think(Board board, CancellationToken ct)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Invoke minimax, starting with zero depth</span></div>
<div class="line">        (FutureMove move, <span class="keywordtype">float</span> score) decision =</div>
<div class="line">            Minimax(board, ct, board.Turn, board.Turn, 0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Return best move</span></div>
<div class="line">        <span class="keywordflow">return</span> decision.move;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Our minimax implementation</span></div>
<div class="line">    <span class="keyword">private</span> (FutureMove move, <span class="keywordtype">float</span> score) Minimax(</div>
<div class="line">        Board board, CancellationToken ct, PColor player, PColor turn, <span class="keywordtype">int</span> depth)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Return invalid move, will always lose</span></div>
<div class="line">        <span class="keywordflow">return</span> (FutureMove.NoMove, <span class="keywordtype">float</span>.NaN);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>The infrastructure is all set. The following steps have to be implemented in the <code>Minimax()</code> function:</p>
<ol type="1">
<li>If the cancellation token was activated, return immediately with a "no move" (score is irrelevant).</li>
<li>Otherwise, if the board is in a final state, return the appropriate score (move is irrelevant since no moves can be made on a final board):<ul>
<li>If the winner is the AI, return the highest possible score.</li>
<li>If the winner is the opponent, return the lowest possible score.</li>
<li>If the match ended in a draw, return a score of zero.</li>
</ul>
</li>
<li>Otherwise, if the maximum depth has been reached, return the score provided by the heuristic function (move is irrelevant, since the game tree will not be branched further below this depth, and as such, there's no move to chose from).</li>
<li>Otherwise, for each possible move, invoke <code>Minimax()</code> recursively, selecting the best score and associated move (i.e., maximizing) if it's the AI's turn, or selecting the worst score and associated move (i.e., minimizing) if it's the opponent's turn.</li>
</ol>
<p>Implementing this reasoning in the <code>Minimax()</code> function can be done as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">private</span> (FutureMove move, <span class="keywordtype">float</span> score) Minimax(</div>
<div class="line">    Board board, CancellationToken ct, PColor player, PColor turn, <span class="keywordtype">int</span> depth)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Move to return and its heuristic value</span></div>
<div class="line">    (FutureMove move, <span class="keywordtype">float</span> score) selectedMove;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Current board state</span></div>
<div class="line">    <a class="code" href="namespace_color_shape_links_1_1_common.html#af06e4e7a85ce74cbf2bcc2e6b36960ff">Winner</a> winner;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If a cancellation request was made...</span></div>
<div class="line">    <span class="keywordflow">if</span> (ct.IsCancellationRequested)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// ...set a &quot;no move&quot; and skip the remaining part of the algorithm</span></div>
<div class="line">        selectedMove = (FutureMove.NoMove, <span class="keywordtype">float</span>.NaN);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Otherwise, if it&#39;s a final board, return the appropriate evaluation</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((winner = board.CheckWinner()) != <a class="code" href="namespace_color_shape_links_1_1_common.html#af06e4e7a85ce74cbf2bcc2e6b36960ff">Winner</a>.None)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (winner.ToPColor() == player)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// AI player wins, return highest possible score</span></div>
<div class="line">            selectedMove = (FutureMove.NoMove, <span class="keywordtype">float</span>.PositiveInfinity);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (winner.ToPColor() == player.Other())</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Opponent wins, return lowest possible score</span></div>
<div class="line">            selectedMove = (FutureMove.NoMove, <span class="keywordtype">float</span>.NegativeInfinity);</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// A draw, return zero</span></div>
<div class="line">            selectedMove = (FutureMove.NoMove, 0f);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// If we&#39;re at maximum depth and don&#39;t have a final board, use</span></div>
<div class="line">    <span class="comment">// the heuristic</span></div>
<div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (depth == maxDepth)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Where did this Heuristic() function come from?</span></div>
<div class="line">        <span class="comment">// We&#39;ll return to it in a moment</span></div>
<div class="line">        selectedMove = (FutureMove.NoMove, Heuristic(board, player));</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">else</span> <span class="comment">// Board not final and depth not at max...</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment">//...so let&#39;s test all possible moves and recursively call Minimax()</span></div>
<div class="line">        <span class="comment">// for each one of them, maximizing or minimizing depending on who&#39;s</span></div>
<div class="line">        <span class="comment">// turn it is</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Initialize the selected move...</span></div>
<div class="line">        selectedMove = turn == player</div>
<div class="line">            <span class="comment">// ...with negative infinity if it&#39;s the AI&#39;s turn and we&#39;re</span></div>
<div class="line">            <span class="comment">// maximizing (so anything except defeat will be better than this)</span></div>
<div class="line">            ? (FutureMove.NoMove, <span class="keywordtype">float</span>.NegativeInfinity)</div>
<div class="line">            <span class="comment">// ...or with positive infinity if it&#39;s the opponent&#39;s turn and we&#39;re</span></div>
<div class="line">            <span class="comment">// minimizing (so anything except victory will be worse than this)</span></div>
<div class="line">            : (FutureMove.NoMove, <span class="keywordtype">float</span>.PositiveInfinity);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Test each column</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Cols; i++)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Skip full columns</span></div>
<div class="line">            <span class="keywordflow">if</span> (board.IsColumnFull(i)) <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Test shapes</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 2; j++)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Get current shape</span></div>
<div class="line">                <a class="code" href="namespace_color_shape_links_1_1_common.html#a00e07dc7f43614733d64deef8e02022e">PShape</a> shape = (<a class="code" href="namespace_color_shape_links_1_1_common.html#a00e07dc7f43614733d64deef8e02022e">PShape</a>)j;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Use this variable to keep the current board&#39;s score</span></div>
<div class="line">                <span class="keywordtype">float</span> eval;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Skip unavailable shapes</span></div>
<div class="line">                <span class="keywordflow">if</span> (board.PieceCount(turn, shape) == 0) <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Test move, call minimax and undo move</span></div>
<div class="line">                board.DoMove(shape, i);</div>
<div class="line">                eval = Minimax(board, ct, player, turn.Other(), depth + 1).score;</div>
<div class="line">                board.UndoMove();</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// If we&#39;re maximizing, is this the best move so far?</span></div>
<div class="line">                <span class="keywordflow">if</span> (turn == player &amp;&amp; eval &gt; selectedMove.score)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// If so, keep it</span></div>
<div class="line">                    selectedMove = (<span class="keyword">new</span> FutureMove(i, shape), eval);</div>
<div class="line">                }</div>
<div class="line">                <span class="comment">// Otherwise, if we&#39;re minimizing, is this the worst move so far?</span></div>
<div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (turn == player.Other() &amp;&amp; eval &lt; selectedMove.score)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// If so, keep it</span></div>
<div class="line">                    selectedMove = (<span class="keyword">new</span> FutureMove(i, shape), eval);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Return selected move and its heuristic value</span></div>
<div class="line">    <span class="keywordflow">return</span> selectedMove;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We're almost there, but there's still a piece missing: the heuristic function. This is a fundamental part of the solution, and as such, only a very basic approach is discussed here. Intuitively, pieces near or at the center of the board potentially contribute to more winning sequences than pieces near corners or edges. This is not a scientific claim, just a (possibly unfounded) guess. As such, let's build an heuristic that values pieces placed closer to the center of the board:</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> System;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ....</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span> <span class="keywordtype">float</span> Heuristic(Board board, PColor color)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Distance between two points</span></div>
<div class="line">    <span class="keywordtype">float</span> Dist(<span class="keywordtype">float</span> x1, <span class="keywordtype">float</span> y1, <span class="keywordtype">float</span> x2, <span class="keywordtype">float</span> y2)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)Math.Sqrt(</div>
<div class="line">            Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Determine the center row</span></div>
<div class="line">    <span class="keywordtype">float</span> centerRow = board.rows / 2;</div>
<div class="line">    <span class="keywordtype">float</span> centerCol = board.cols / 2;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Maximum points a piece can be awarded when it&#39;s at the center</span></div>
<div class="line">    <span class="keywordtype">float</span> maxPoints = Dist(centerRow, centerCol, 0, 0);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Current heuristic value</span></div>
<div class="line">    <span class="keywordtype">float</span> h = 0;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Loop through the board looking for pieces</span></div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; board.rows; i++)</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; board.cols; j++)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// Get piece in current board position</span></div>
<div class="line">            Piece? piece = board[i, j];</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Is there any piece there?</span></div>
<div class="line">            <span class="keywordflow">if</span> (piece.HasValue)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// If the piece is of our color, increment the</span></div>
<div class="line">                <span class="comment">// heuristic inversely to the distance from the center</span></div>
<div class="line">                <span class="keywordflow">if</span> (piece.Value.color == color)</div>
<div class="line">                    h += maxPoints - Dist(centerRow, centerCol, i, j);</div>
<div class="line">                <span class="comment">// Otherwise decrement the heuristic value using the</span></div>
<div class="line">                <span class="comment">// same criteria</span></div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    h -= maxPoints - Dist(centerRow, centerCol, i, j);</div>
<div class="line">                <span class="comment">// If the piece is of our shape, increment the</span></div>
<div class="line">                <span class="comment">// heuristic inversely to the distance from the center</span></div>
<div class="line">                <span class="keywordflow">if</span> (piece.Value.shape == color.Shape())</div>
<div class="line">                    h += maxPoints - Dist(centerRow, centerCol, i, j);</div>
<div class="line">                <span class="comment">// Otherwise decrement the heuristic value using the</span></div>
<div class="line">                <span class="comment">// same criteria</span></div>
<div class="line">                <span class="keywordflow">else</span></div>
<div class="line">                    h -= maxPoints - Dist(centerRow, centerCol, i, j);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Return the final heuristic score for the given board</span></div>
<div class="line">    <span class="keywordflow">return</span> h;</div>
<div class="line">}</div>
</div><!-- fragment --><p>We now have a working AI thinker. We can make our thinker more flexible by allowing the maximum depth to be specified using the <code>Setup()</code> parameters string:</p>
<div class="fragment"><div class="line"><span class="comment">// The Setup() method, optional override</span></div>
<div class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">void</span> Setup(<span class="keywordtype">string</span> str)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Try to get the maximum depth from the parameters</span></div>
<div class="line">    <span class="keywordflow">if</span> (!<span class="keywordtype">int</span>.TryParse(str, out maxDepth))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// If not possible, set it to 3 by default</span></div>
<div class="line">        maxDepth = 3;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p>It would also be useful to differentiate between instances of our AI thinker parameterized with various maximum depths, playing against each other in matches or tournaments. This can be accomplished by overriding the <code>ToString()</code> method and customizing the AI thinker's name:</p>
<div class="fragment"><div class="line"><span class="comment">// The ToString() method, optional override</span></div>
<div class="line"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">string</span> ToString()</div>
<div class="line">{</div>
<div class="line">   <span class="keywordflow">return</span> base.ToString() + <span class="stringliteral">&quot;D&quot;</span> + maxDepth;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Although this implementation will win against a random player (unless the random player is really lucky), and probably some human players as well, it's in reality a very simple solution. Thus, while it's a good way of getting started in board game AI, it won't go very far in a competition. The complete code of this AI thinker is as follows (it's also in the <a class="el" href="class_color_shape_links_1_1_common_1_1_a_i_1_1_examples_1_1_minimax_a_i_thinker.html">MinimaxAIThinker</a> class, included with the development framework):</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> System;</div>
<div class="line"><span class="keyword">using</span> System.Threading;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespace_color_shape_links.html">ColorShapeLinks</a>.<a class="code" href="namespace_color_shape_links_1_1_common.html">Common</a>;</div>
<div class="line"><span class="keyword">using</span> <a class="code" href="namespace_color_shape_links.html">ColorShapeLinks</a>.<a class="code" href="namespace_color_shape_links_1_1_common.html">Common</a>.<a class="code" href="namespace_color_shape_links_1_1_common_1_1_a_i.html">AI</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>MyAIThinker : AbstractThinker</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Maximum depth</span></div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">int</span> maxDepth;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The Setup() method, optional override</span></div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">void</span> Setup(<span class="keywordtype">string</span> str)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Try to get the maximum depth from the parameters</span></div>
<div class="line">        <span class="keywordflow">if</span> (!<span class="keywordtype">int</span>.TryParse(str, out maxDepth))</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// If not possible, set it to 3 by default</span></div>
<div class="line">            maxDepth = 3;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The ToString() method, optional override</span></div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keywordtype">string</span> ToString()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> base.ToString() + <span class="stringliteral">&quot;D&quot;</span> + maxDepth;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// The Think() method (mandatory override) is invoked by the game engine</span></div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">override</span> FutureMove Think(Board board, CancellationToken ct)</div>
<div class="line">    {</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Invoke minimax, starting with zero depth</span></div>
<div class="line">        (FutureMove move, <span class="keywordtype">float</span> score) decision =</div>
<div class="line">            Minimax(board, ct, board.Turn, board.Turn, 0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Return best move</span></div>
<div class="line">        <span class="keywordflow">return</span> decision.move;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Minimax implementation</span></div>
<div class="line">    <span class="keyword">private</span> (FutureMove move, <span class="keywordtype">float</span> score) Minimax(</div>
<div class="line">        Board board, CancellationToken ct,</div>
<div class="line">        PColor player, PColor turn, <span class="keywordtype">int</span> depth)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Move to return and its heuristic value</span></div>
<div class="line">        (FutureMove move, <span class="keywordtype">float</span> score) selectedMove;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Current board state</span></div>
<div class="line">        <a class="code" href="namespace_color_shape_links_1_1_common.html#af06e4e7a85ce74cbf2bcc2e6b36960ff">Winner</a> winner;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If a cancellation request was made...</span></div>
<div class="line">        <span class="keywordflow">if</span> (ct.IsCancellationRequested)</div>
<div class="line">        {</div>
<div class="line">            <span class="comment">// ...set a &quot;no move&quot; and skip the remaining part of the algorithm</span></div>
<div class="line">            selectedMove = (FutureMove.NoMove, <span class="keywordtype">float</span>.NaN);</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Otherwise, if it&#39;s a final board, return the appropriate evaluation</span></div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((winner = board.CheckWinner()) != <a class="code" href="namespace_color_shape_links_1_1_common.html#af06e4e7a85ce74cbf2bcc2e6b36960ff">Winner</a>.None)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (winner.ToPColor() == player)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// AI player wins, return highest possible score</span></div>
<div class="line">                selectedMove = (FutureMove.NoMove, <span class="keywordtype">float</span>.PositiveInfinity);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (winner.ToPColor() == player.Other())</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Opponent wins, return lowest possible score</span></div>
<div class="line">                selectedMove = (FutureMove.NoMove, <span class="keywordtype">float</span>.NegativeInfinity);</div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// A draw, return zero</span></div>
<div class="line">                selectedMove = (FutureMove.NoMove, 0f);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// If we&#39;re at maximum depth and don&#39;t have a final board, use</span></div>
<div class="line">        <span class="comment">// the heuristic</span></div>
<div class="line">        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (depth == maxDepth)</div>
<div class="line">        {</div>
<div class="line">            selectedMove = (FutureMove.NoMove, Heuristic(board, player));</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">else</span> <span class="comment">// Board not final and depth not at max...</span></div>
<div class="line">        {</div>
<div class="line">            <span class="comment">//...so let&#39;s test all possible moves and recursively call Minimax()</span></div>
<div class="line">            <span class="comment">// for each one of them, maximizing or minimizing depending on who&#39;s</span></div>
<div class="line">            <span class="comment">// turn it is</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Initialize the selected move...</span></div>
<div class="line">            selectedMove = turn == player</div>
<div class="line">                <span class="comment">// ...with negative infinity if it&#39;s the AI&#39;s turn and we&#39;re</span></div>
<div class="line">                <span class="comment">// maximizing (so anything except defeat will be better than this)</span></div>
<div class="line">                ? (FutureMove.NoMove, <span class="keywordtype">float</span>.NegativeInfinity)</div>
<div class="line">                <span class="comment">// ...or with positive infinity if it&#39;s the opponent&#39;s turn and we&#39;re</span></div>
<div class="line">                <span class="comment">// minimizing (so anything except victory will be worse than this)</span></div>
<div class="line">                : (FutureMove.NoMove, <span class="keywordtype">float</span>.PositiveInfinity);</div>
<div class="line"> </div>
<div class="line">            <span class="comment">// Test each column</span></div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; Cols; i++)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Skip full columns</span></div>
<div class="line">                <span class="keywordflow">if</span> (board.IsColumnFull(i)) <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Test shapes</span></div>
<div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 2; j++)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// Get current shape</span></div>
<div class="line">                    <a class="code" href="namespace_color_shape_links_1_1_common.html#a00e07dc7f43614733d64deef8e02022e">PShape</a> shape = (<a class="code" href="namespace_color_shape_links_1_1_common.html#a00e07dc7f43614733d64deef8e02022e">PShape</a>)j;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Use this variable to keep the current board&#39;s score</span></div>
<div class="line">                    <span class="keywordtype">float</span> eval;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Skip unavailable shapes</span></div>
<div class="line">                    <span class="keywordflow">if</span> (board.PieceCount(turn, shape) == 0) <span class="keywordflow">continue</span>;</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// Test move, call minimax and undo move</span></div>
<div class="line">                    board.DoMove(shape, i);</div>
<div class="line">                    eval = Minimax(board, ct, player, turn.Other(), depth + 1).score;</div>
<div class="line">                    board.UndoMove();</div>
<div class="line"> </div>
<div class="line">                    <span class="comment">// If we&#39;re maximizing, is this the best move so far?</span></div>
<div class="line">                    <span class="keywordflow">if</span> (turn == player</div>
<div class="line">                        &amp;&amp; eval &gt;= selectedMove.score)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">// If so, keep it</span></div>
<div class="line">                        selectedMove = (<span class="keyword">new</span> FutureMove(i, shape), eval);</div>
<div class="line">                    }</div>
<div class="line">                    <span class="comment">// Otherwise, if we&#39;re minimizing, is this the worst move so far?</span></div>
<div class="line">                    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (turn == player.Other()</div>
<div class="line">                        &amp;&amp; eval &lt;= selectedMove.score)</div>
<div class="line">                    {</div>
<div class="line">                        <span class="comment">// If so, keep it</span></div>
<div class="line">                        selectedMove = (<span class="keyword">new</span> FutureMove(i, shape), eval);</div>
<div class="line">                    }</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Return movement and its heuristic value</span></div>
<div class="line">        <span class="keywordflow">return</span> selectedMove;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Heuristic function</span></div>
<div class="line">    <span class="keyword">private</span> <span class="keywordtype">float</span> Heuristic(Board board, PColor color)</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Distance between two points</span></div>
<div class="line">        <span class="keywordtype">float</span> Dist(<span class="keywordtype">float</span> x1, <span class="keywordtype">float</span> y1, <span class="keywordtype">float</span> x2, <span class="keywordtype">float</span> y2)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">return</span> (<span class="keywordtype">float</span>)Math.Sqrt(</div>
<div class="line">                Math.Pow(x1 - x2, 2) + Math.Pow(y1 - y2, 2));</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Determine the center row</span></div>
<div class="line">        <span class="keywordtype">float</span> centerRow = board.rows / 2;</div>
<div class="line">        <span class="keywordtype">float</span> centerCol = board.cols / 2;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Maximum points a piece can be awarded when it&#39;s at the center</span></div>
<div class="line">        <span class="keywordtype">float</span> maxPoints = Dist(centerRow, centerCol, 0, 0);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Current heuristic value</span></div>
<div class="line">        <span class="keywordtype">float</span> h = 0;</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Loop through the board looking for pieces</span></div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; board.rows; i++)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; board.cols; j++)</div>
<div class="line">            {</div>
<div class="line">                <span class="comment">// Get piece in current board position</span></div>
<div class="line">                Piece? piece = board[i, j];</div>
<div class="line"> </div>
<div class="line">                <span class="comment">// Is there any piece there?</span></div>
<div class="line">                <span class="keywordflow">if</span> (piece.HasValue)</div>
<div class="line">                {</div>
<div class="line">                    <span class="comment">// If the piece is of our color, increment the</span></div>
<div class="line">                    <span class="comment">// heuristic inversely to the distance from the center</span></div>
<div class="line">                    <span class="keywordflow">if</span> (piece.Value.color == color)</div>
<div class="line">                        h += maxPoints - Dist(centerRow, centerCol, i, j);</div>
<div class="line">                    <span class="comment">// Otherwise decrement the heuristic value using the</span></div>
<div class="line">                    <span class="comment">// same criteria</span></div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        h -= maxPoints - Dist(centerRow, centerCol, i, j);</div>
<div class="line">                    <span class="comment">// If the piece is of our shape, increment the</span></div>
<div class="line">                    <span class="comment">// heuristic inversely to the distance from the center</span></div>
<div class="line">                    <span class="keywordflow">if</span> (piece.Value.shape == color.Shape())</div>
<div class="line">                        h += maxPoints - Dist(centerRow, centerCol, i, j);</div>
<div class="line">                    <span class="comment">// Otherwise decrement the heuristic value using the</span></div>
<div class="line">                    <span class="comment">// same criteria</span></div>
<div class="line">                    <span class="keywordflow">else</span></div>
<div class="line">                        h -= maxPoints - Dist(centerRow, centerCol, i, j);</div>
<div class="line">                }</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// Return the final heuristic score for the given board</span></div>
<div class="line">        <span class="keywordflow">return</span> h;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespace_color_shape_links_1_1_common_1_1_a_i_html"><div class="ttname"><a href="namespace_color_shape_links_1_1_common_1_1_a_i.html">ColorShapeLinks.Common.AI</a></div><div class="ttdoc">Common AI-related types between all ColorShapeLinks implementations.</div><div class="ttdef"><b>Definition:</b> AbstractThinker.cs:12</div></div>
<div class="ttc" id="anamespace_color_shape_links_html"><div class="ttname"><a href="namespace_color_shape_links.html">ColorShapeLinks</a></div><div class="ttdoc">The ColorShapeLinks game, an unbounded version of the Simplexity board game.</div><div class="ttdef"><b>Definition:</b> AIPlayer.cs:12</div></div>
<div class="ttc" id="anamespace_color_shape_links_1_1_common_html_a00e07dc7f43614733d64deef8e02022e"><div class="ttname"><a href="namespace_color_shape_links_1_1_common.html#a00e07dc7f43614733d64deef8e02022e">ColorShapeLinks.Common.PShape</a></div><div class="ttdeci">PShape</div><div class="ttdoc">Piece shapes.</div><div class="ttdef"><b>Definition:</b> PShape.cs:11</div></div>
<div class="ttc" id="anamespace_color_shape_links_1_1_common_html"><div class="ttname"><a href="namespace_color_shape_links_1_1_common.html">ColorShapeLinks.Common</a></div><div class="ttdoc">The common code between all ColorShapeLinks implementations.</div><div class="ttdef"><b>Definition:</b> AbstractThinker.cs:12</div></div>
<div class="ttc" id="anamespace_color_shape_links_1_1_common_html_af06e4e7a85ce74cbf2bcc2e6b36960ff"><div class="ttname"><a href="namespace_color_shape_links_1_1_common.html#af06e4e7a85ce74cbf2bcc2e6b36960ff">ColorShapeLinks.Common.Winner</a></div><div class="ttdeci">Winner</div><div class="ttdoc">Winner or result of match.</div><div class="ttdef"><b>Definition:</b> Winner.cs:11</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Mar 16 2020 23:51:20 for ColorShapeLinks AI by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.16 </li>
  </ul>
</div>
</body>
</html>
